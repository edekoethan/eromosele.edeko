#!/usr/bin/env node
/**
 * move_images_update_imports.js
 *
 * Usage:
 *   node move_images_update_imports.js --dry-run        # list planned moves and replacements (default)
 *   node move_images_update_imports.js --apply          # apply changes, create branch, commit & push
 *   node move_images_update_imports.js --apply --publish # apply and also run ./publish_local.sh if present
 *
 * What it does:
 *  - Finds image files in ./public (png/jpg/jpeg/gif/webp/svg/bmp/ico)
 *  - Moves them to ./src/assets (creating directories as needed)
 *  - Generates ./src/lib/assets.js exporting a default map { "name.ext": new URL('../assets/name.ext', import.meta.url).href, ... }
 *  - Scans source files (src/**/*.astro, mdx, jsx, tsx, js, ts) and replaces occurrences like src="/file.png" or href="/file.png"
 *    with src={assets['file.png']} and inserts `import assets from '<rel-path-to-src/lib/assets.js>'` at top / in astro frontmatter.
 *  - For plain .md files (non-MDX), replaces src="/file.png" → src="/eromosele.edeko/file.png" as a safe fallback.
 *  - Creates a branch fix/move-images-YYYYMMDDHHMMSS, commits changes and pushes to origin if --apply is used.
 *
 * IMPORTANT:
 *  - Review the dry-run output before running --apply.
 *  - Script assumes a git repo and that origin exists.
 */

const fs = require('fs');
const path = require('path');
const child_process = require('child_process');

const allowedImageExt = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg', '.bmp', '.ico'];
const repoBase = 'eromosele.edeko';
const publicDir = path.join(process.cwd(), 'public');
const targetAssetsDir = path.join(process.cwd(), 'src', 'assets');
const assetsModulePath = path.join(process.cwd(), 'src', 'lib', 'assets.js');
const srcDir = path.join(process.cwd(), 'src');

const argv = process.argv.slice(2);
const DRY_RUN = !argv.includes('--apply');
const DO_PUBLISH = argv.includes('--publish');

function run(cmd, opts = {}) {
  return child_process.execSync(cmd, { stdio: 'pipe', encoding: 'utf8', ...opts }).trim();
}

function ensureDirSync(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function listFilesRecursive(dir, exts = null) {
  let out = [];
  if (!fs.existsSync(dir)) return out;
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) out = out.concat(listFilesRecursive(full, exts));
    else {
      if (!exts || exts.includes(path.extname(e.name).toLowerCase())) out.push(full);
    }
  }
  return out;
}

function findImageFilesInPublic() {
  if (!fs.existsSync(publicDir)) return [];
  return listFilesRecursive(publicDir).filter(f => allowedImageExt.includes(path.extname(f).toLowerCase()));
}

function slugFilename(fname) {
  // keep original filename as key (including extension)
  return path.basename(fname);
}

function relativeImportPath(fromFile, toFile) {
  let rel = path.relative(path.dirname(fromFile), toFile);
  if (!rel.startsWith('.')) rel = './' + rel;
  // Use posix style for imports in JS source (replace backslashes)
  return rel.split(path.sep).join('/');
}

function detectTextFileType(file) {
  const ext = path.extname(file).toLowerCase();
  if (ext === '.astro') return 'astro';
  if (ext === '.mdx' || ext === '.md') return ext === '.mdx' ? 'mdx' : 'md';
  if (ext === '.jsx' || ext === '.tsx' || ext === '.js' || ext === '.ts' || ext === '.mjs') return 'module';
  return null;
}

function scanSourceFiles() {
  const exts = ['.astro','.mdx','.md','.jsx','.tsx','.js','.ts','.mjs'];
  return listFilesRecursive(srcDir).filter(f => exts.includes(path.extname(f).toLowerCase()));
}

function buildAssetsModuleContent(imagePaths) {
  // imagePaths: array of absolute paths to src/assets/<file>
  // generate contents that export default { "name.ext": new URL('../assets/name.ext', import.meta.url).href, ... }
  // assets module will live at src/lib/assets.js so relative path from that file to assets is ../assets/NAME
  let lines = [];
  lines.push('// Auto-generated by move_images_update_imports.js');
  lines.push('// Do not edit by hand (re-run the script to update).');
  lines.push('');
  lines.push('const assets = {');
  for (const p of imagePaths) {
    const name = slugFilename(p);
    const relFromModuleToAsset = path.posix.join('../assets', name); // assets module is in src/lib/
    lines.push(`  ${JSON.stringify(name)}: new URL(${JSON.stringify(relFromModuleToAsset)}, import.meta.url).href,`);
  }
  lines.push('};');
  lines.push('');
  lines.push('export default assets;');
  lines.push('');
  return lines.join('\n');
}

function replaceInFileForModules(filePath, imageNameSet, assetsImportRel) {
  // filePath is a component/module/mdx where we can insert JS import
  // Returns { changed:bool, newContent, replacements: [{old, new, index}] }
  let text = fs.readFileSync(filePath, 'utf8');
  const orig = text;
  const ext = path.extname(filePath).toLowerCase();
  const fileType = detectTextFileType(filePath);
  let replacements = [];
  // Regex: (src|href)=["']\/([^"']+\.(png|jpg|jpeg|gif|webp|svg|bmp|ico))["']
  const re = /(\b(?:src|href))=(["'])\/([^"']+\.(?:png|jpg|jpeg|gif|webp|svg|bmp|ico))\2/gi;

  let match;
  let any = false;
  let offset = 0;
  let out = text;
  // collect matches first to avoid overlapping index mess
  let matches = [];
  while ((match = re.exec(text)) !== null) {
    const full = match[0];
    const attr = match[1];
    const quote = match[2];
    const pathInside = match[3]; // e.g., me_image_2.png or foo/bar.png
    const basename = path.posix.basename(pathInside);
    if (!imageNameSet.has(basename)) continue; // only touch images we moved
    matches.push({ index: match.index, length: full.length, attr, quote, pathInside, basename });
  }

  if (matches.length === 0) return { changed: false, newContent: text, replacements: [] };

  // For module-like files we will:
  // 1) Ensure an import assets from 'REL' exists (if not, add at top or into astro frontmatter)
  // 2) Replace src="/file.png" -> src={assets['file.png']}
  // For .astro specifically we'll insert into frontmatter (--- ... ---)
  // For mdx and module files we'll insert import at top if missing.

  // 1) ensure import present
  let importSpecifier = `assets`;
  let importStatement = `import ${importSpecifier} from '${assetsImportRel}';`;
  if (fileType === 'astro') {
    // find frontmatter delimiters
    if (/^\s*---/.test(text)) {
      // find end of frontmatter
      const fmEnd = text.indexOf('---', 3);
      if (fmEnd !== -1) {
        // Check if import already inside frontmatter
        const fm = text.slice(0, fmEnd + 3);
        if (!fm.includes(importStatement)) {
          // insert import after first --- line
          const afterFirst = fm.split('\n');
          // insert import after the opening line
          afterFirst.splice(1, 0, importStatement);
          const newFrontmatter = afterFirst.join('\n');
          text = newFrontmatter + text.slice(fmEnd + 3);
        }
      } else {
        // unusual: no closing frontmatter, just prepend one
        text = `---\n${importStatement}\n---\n` + text;
      }
    } else {
      // no frontmatter — create one
      text = `---\n${importStatement}\n---\n` + text;
    }
  } else {
    // mdx/module files: add import at top if not present
    if (!text.includes(importStatement)) {
      text = importStatement + '\n' + text;
    }
  }

  // perform replacements
  // We re-run regex on new text to replace occurrences, but be careful not to touch already-updated ones
  // Replacement: src="/foo.png" -> src={assets['foo.png']}
  text = text.replace(/(\b(?:src|href))=(["'])\/([^"']+\.(?:png|jpg|jpeg|gif|webp|svg|bmp|ico))\2/gi, (m, attr, quote, pathInside) => {
    const basename = path.posix.basename(pathInside);
    if (!imageNameSet.has(basename)) return m; // skip
    any = true;
    replacements.push({ old: m, new: `${attr}={assets[${JSON.stringify(basename)}]}` });
    return `${attr}={assets[${JSON.stringify(basename)}]}`;
  });

  return { changed: any || replacements.length > 0, newContent: text, replacements };
}

function replaceInFileForMarkdown(filePath, imageNameSet) {
  // For plain .md files (non-MDX), convert image links like ![alt](/file.png) or <img src="/file.png"> to repo-prefixed absolute path.
  let text = fs.readFileSync(filePath, 'utf8');
  const orig = text;
  let changed = false;
  // Replace inline HTML src/href occurrences
  text = text.replace(/(\b(?:src|href))=(["'])\/([^"']+\.(?:png|jpg|jpeg|gif|webp|svg|bmp|ico))\2/gi, (m, attr, quote, pathInside) => {
    const basename = path.posix.basename(pathInside);
    if (!imageNameSet.has(basename)) return m;
    changed = true;
    return `${attr}=${quote}/${repoBase}/${pathInside}${quote}`;
  });
  // Replace Markdown image syntax ![alt](/path/to/img.png)
  text = text.replace(/!\[([^\]]*)\]\((\/[^)]+\.(?:png|jpg|jpeg|gif|webp|svg|bmp|ico))\)/gi, (m, alt, url) => {
    const basename = path.posix.basename(url);
    if (!imageNameSet.has(basename)) return m;
    changed = true;
    return `![${alt}](/${repoBase}${url})`;
  });
  return { changed, newContent: text };
}

(async function main() {
  console.log(`Starting move_images_update_imports.js (${DRY_RUN ? 'dry-run' : 'apply'})`);
  const images = findImageFilesInPublic();
  if (images.length === 0) {
    console.log('No images found in public/. Nothing to do.');
    process.exit(0);
  }
  console.log(`Found ${images.length} image(s) in public/:`);
  images.forEach(i => console.log('  - ' + path.relative(process.cwd(), i)));

  // Prepare destination list
  ensureDirSync(targetAssetsDir);
  const plannedMoves = images.map(src => {
    const dest = path.join(targetAssetsDir, path.basename(src));
    return { src, dest, name: path.basename(src) };
  });

  // Dry-run summary: list all source files we'll scan and the planned regex matches (first 50)
  const sourceFiles = scanSourceFiles();
  console.log(`\nScanning ${sourceFiles.length} source file(s) under src/ for absolute-root image references...`);
  const imageNameSet = new Set(plannedMoves.map(m => m.name));
  let totalMatches = 0;
  const matchSamples = [];

  const scanRe = /(\b(?:src|href))=(["'])\/([^"']+\.(?:png|jpg|jpeg|gif|webp|svg|bmp|ico))\2/gi;
  const mdImgRe = /!\[([^\]]*)\]\((\/[^)]+\.(?:png|jpg|jpeg|gif|webp|svg|bmp|ico))\)/gi;

  for (const f of sourceFiles) {
    const txt = fs.readFileSync(f, 'utf8');
    let m;
    while ((m = scanRe.exec(txt)) !== null) {
      const basename = path.posix.basename(m[3]);
      if (imageNameSet.has(basename)) {
        totalMatches++;
        if (matchSamples.length < 50) matchSamples.push({ file: path.relative(process.cwd(), f), line: getLineForIndex(txt, m.index), snippet: m[0] });
      }
    }
    // markdown syntax
    if (f.endsWith('.md')) {
      while ((m = mdImgRe.exec(txt)) !== null) {
        const basename = path.posix.basename(m[2]);
        if (imageNameSet.has(basename)) {
          totalMatches++;
          if (matchSamples.length < 50) matchSamples.push({ file: path.relative(process.cwd(), f), line: getLineForIndex(txt, m.index), snippet: m[0] });
        }
      }
    }
  }

  function getLineForIndex(text, idx) {
    const before = text.slice(0, idx);
    return before.split('\n').length;
  }

  console.log(`\nFound ${totalMatches} matching absolute-root image references across source files.`);
  if (matchSamples.length > 0) {
    console.log('\nFirst matches (file:line):');
    matchSamples.forEach(s => {
      console.log(`  - ${s.file}:${s.line}    ${s.snippet}`);
    });
  }

  if (DRY_RUN) {
    console.log('\nDry-run mode: no files will be changed. To apply changes, re-run with --apply.');
    process.exit(0);
  }

  // If apply mode:
  // 1) Create branch
  const branchName = `fix/move-images-${new Date().toISOString().replace(/[-:]/g,'').replace(/\..*/,'')}`;
  console.log(`\nCreating and switching to git branch ${branchName}...`);
  run(`git checkout -b ${branchName}`);
  console.log('Branch created.');

  // 2) Move images (overwrite if dest exists)
  console.log('\nMoving images to src/assets/ ...');
  for (const p of plannedMoves) {
    ensureDirSync(path.dirname(p.dest));
    fs.copyFileSync(p.src, p.dest);
    fs.unlinkSync(p.src);
    console.log(`  - moved ${path.relative(process.cwd(), p.src)} -> ${path.relative(process.cwd(), p.dest)}`);
  }

  // 3) Build assets module
  ensureDirSync(path.dirname(assetsModulePath));
  const assetPaths = plannedMoves.map(m => m.dest);
  const assetsModuleContent = buildAssetsModuleContent(assetPaths);
  fs.writeFileSync(assetsModulePath, assetsModuleContent, 'utf8');
  console.log(`\nWrote assets module: ${path.relative(process.cwd(), assetsModulePath)}`);

  // 4) Update source files
  console.log('\nUpdating source files to use assets map...');
  let filesChanged = 0;
  for (const f of sourceFiles) {
    const ext = path.extname(f).toLowerCase();
    const fileType = detectTextFileType(f);
    let changed = false;
    if (fileType === 'astro' || fileType === 'module' || fileType === 'mdx') {
      // compute relative import path to assets module
      const relImport = relativeImportPath(f, assetsModulePath);
      const res = replaceInFileForModules(f, imageNameSet, relImport);
      if (res.changed) {
        fs.writeFileSync(f, res.newContent, 'utf8');
        filesChanged++;
        console.log(`  - updated ${path.relative(process.cwd(), f)} (${res.replacements ? res.replacements.length : 0} replacements)`);
      }
    } else if (fileType === 'md') {
      const res = replaceInFileForMarkdown(f, imageNameSet);
      if (res.changed) {
        fs.writeFileSync(f, res.newContent, 'utf8');
        filesChanged++;
        console.log(`  - updated ${path.relative(process.cwd(), f)} (markdown image links)`);
      }
    }
  }

  // 5) git add + commit + push
  console.log(`\nStaging changes and committing...`);
  run('git add -A');
  run(`git commit -m "Move public images -> src/assets and update imports for GitHub Pages" || true`);
  console.log('Commit created (if changes existed).');
  console.log(`Pushing branch ${branchName} to origin...`);
  run(`git push -u origin ${branchName}`);
  console.log('Push complete.');

  if (DO_PUBLISH) {
    if (fs.existsSync(path.join(process.cwd(), 'publish_local.sh'))) {
      console.log('Running publish_local.sh --yes to rebuild & publish...');
      try {
        run('./publish_local.sh --yes', { stdio: 'inherit' });
        console.log('publish_local.sh finished.');
      } catch (err) {
        console.error('publish_local.sh failed:', err.message);
      }
    } else {
      console.log('publish_local.sh not found, skipping publish step.');
    }
  }

  console.log('\nDone. Review the branch on GitHub, verify that components compile locally, then merge to main.');
})();
